    a hands-on tutorial you can follow start-to-finish to run Terraform that deploys to AWS using GitHub Actions or GitLab CI/CD. It focuses on secure, optimized, and 
    practical defaults: short-lived credentials via OIDC, encrypted remote state (S3 + DynamoDB locking), least-privilege IAM, automated plan as PR checks and gated 
    apply on protected branches/environments, plus static/security checks (tflint, tfsec/checkov).


    Architecture & Prerequisites
    =============================

    step-by-step setup (create backend resources, IAM roles for OIDC)
    a small example Terraform project (S3 bucket + versioning + encryption)
    complete GitHub Actions workflow (plan + apply with OIDC)
    complete GitLab CI pipeline (plan + apply with OIDC)
    security & operational best practices checklist


 1) Architecture (what you’ll build)
 ====================================

    Terraform code lives in a repo.
    Terraform remote state stored in an AWS S3 bucket (server side encryption, versioning).
    DynamoDB table for state locking.
    CI uses OIDC (no long-lived AWS keys in CI):
        GitHub Actions → GitHub OIDC → Assume an IAM role in AWS.
        GitLab CI/CD → GitLab OIDC (JWT) → Assume an IAM role in AWS.

    CI jobs:

        terraform fmt / tflint / tfsec in PRs
        terraform plan on PRs
        terraform apply only on main or via an environment approval step.


 2) Prerequisites
 =================

    AWS account with admin access for initial setup (creating the S3 bucket, DynamoDB table, and the OIDC-role).
    Repo on GitHub or GitLab.
    aws cli and terraform locally for initial resources (optional but handy).
    Terraform >= 1.0 recommended.

 3) Create Terraform remote-state resources (S3 + DynamoDB)
 ===========================================================

    You can create these with AWS Console or AWS CLI. Example CLI (replace <region>, <tfstate-bucket>, <dynamodb-table>):

        export AWS_REGION="eu-central-1"
        export TFSTATE_BUCKET="my-terraform-state-12345"
        export DDB_TABLE="my-tf-locks"

    # create S3 bucket (for eu-central-1 you must set LocationConstraint)
    aws s3api create-bucket \
        --bucket $TFSTATE_BUCKET \
        --region $AWS_REGION \
        --create-bucket-configuration LocationConstraint=$AWS_REGION

    # enable versioning
    aws s3api put-bucket-versioning \
        --bucket $TFSTATE_BUCKET \
        --versioning-configuration Status=Enabled

    # enable default encryption (SSE-S3 or SSE-KMS; SSE-S3 shown)
    aws s3api put-bucket-encryption \
        --bucket $TFSTATE_BUCKET \
        --server-side-encryption-configuration '{
            "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]
        }'

    # create DynamoDB table for state locking
    aws dynamodb create-table \
        --table-name $DDB_TABLE \
        --attribute-definitions AttributeName=LockID,AttributeType=S \
        --key-schema AttributeName=LockID,KeyType=HASH \
        --billing-mode PAY_PER_REQUEST \
        --region $AWS_REGION

    Note: If you prefer KMS, create a KMS key and set the S3 bucket encryption to use it. Use proper key policy and grants.


 4) Create an AWS IAM role for CI to assume (OIDC, least privilege)
 ===================================================================

    Why OIDC? It emits a short-lived token CI can use to sts:AssumeRoleWithWebIdentity — no long-lived tokens in repo.

    Below are two sample trust policy snippets you’ll adapt: one for GitHub and one for GitLab. Replace OWNER/REPO or project identifiers and the AWS account id.


    4a) GitHub OIDC trust policy (example)
    ----------------------------------------

    Create role CI-Terraform-Role. Trust policy:

    {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": { "Federated": "arn:aws:iam::123456789012:oidc-provider/token.actions.githubusercontent.com" },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                    "StringEquals": {
                        "token.actions.githubusercontent.com:aud": "sts.amazonaws.com",
                        "token.actions.githubusercontent.com:sub": "repo:OWNER/REPO:ref:refs/heads/main"
                    }
                }
            }
        ]
    }


    If you want to allow PRs from forks to only run plan (but not apply), choose trust conditions carefully or use separate roles.

    4b) GitLab OIDC trust policy (example)
    ---------------------------------------

    GitLab’s issuer is https://gitlab.com. You’ll create a role whose trust policy allows GitLab’s OIDC tokens (project scope). A basic example:

    {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": { "Federated": "arn:aws:iam::123456789012:oidc-provider/gitlab.com" },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                    "StringEquals": {
                        "gitlab.com:sub": "project_path:namespace/project",   /* adapt to your claim */
                        "gitlab.com:aud": "sts.amazonaws.com"
                    }
                }
            }
        ]
    }


    Important: on GitLab.com the OIDC issuer and claim names differ; check docs and adjust sub condition to match project. (Typical sub looks like project_path:namespace/project:ref:refs/heads/main or similar.)


    4c) IAM permissions (least-privilege example)
    -----------------------------------------------

    For Terraform you often need broad resource permissions; start with a policy that allows managing resources for the scope of that repo (here’s minimal for state management + S3 & DynamoDB + ability to create typical infra — expand to your resources later):

    {
        "Version": "2012-10-17",
        "Statement": [
            {
            "Sid": "StateBackendAccess",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:GetObjectVersion",
                "s3:PutObject",
                "s3:ListBucket",
                "s3:DeleteObject"
            ],
            "Resource": [
                "arn:aws:s3:::my-terraform-state-12345",
                "arn:aws:s3:::my-terraform-state-12345/*"
            ]
        },
        {
            "Sid": "DynamoDBLocking",
            "Effect": "Allow",
            "Action": [
                "dynamodb:GetItem",
                "dynamodb:PutItem",
                "dynamodb:DeleteItem",
                "dynamodb:UpdateItem"
            ],
            "Resource": "arn:aws:dynamodb:eu-central-1:123456789012:table/my-tf-locks"
        },

            /* Add resource specific permissions below (example S3 full, EC2 full) - replace with narrow ARNs */
            {
            "Sid": "TerraformResourceManagement",
            "Effect": "Allow",
            "Action": [
                "ec2:*",
                "s3:*",
                "iam:PassRole",
                "iam:GetRole",
                "kms:*",
                "rds:*"
            ],
            "Resource": "*"
            }
        ]
    }

    Goal: narrow "TerraformResourceManagement" to specific ARNs later. Use separate roles for different environments (dev/prod) with stricter permissions for prod.


    5) Terraform example repo (minimal): remote backend + S3 bucket resource
    -------------------------------------------------------------------------

    Create a repository with files:

    backend.tf
    -----------
        terraform {
            required_version = ">= 1.0"

            backend "s3" {
                bucket         = "my-terraform-state-12345" # replace
                key            = "example-project/terraform.tfstate"
                region         = "eu-central-1"
                dynamodb_table = "my-tf-locks"
                encrypt        = true
            }
        }


    provider.tf
    ------------
        provider "aws" {
            region = var.aws_region
        }


    variables.tf
    -------------
        variable "aws_region" {
            type    = string
                default = "eu-central-1"
            }

            variable "bucket_name" {
                type = string
        }


    main.tf
    --------
    This creates a secure S3 bucket as a sample resource:

        resource "aws_s3_bucket" "example" {
            bucket = var.bucket_name

            versioning {
                enabled = true
            }

        server_side_encryption_configuration {
            rule {
                apply_server_side_encryption_by_default {
                    sse_algorithm = "AES256"
                }
            }
        }

        tags = {
            Name = "example-terraform-bucket"
            Env  = "dev"
        }
        }

        output "bucket_arn" {
            value = aws_s3_bucket.example.arn
        }


    outputs.tf
    ------------
    (see above)

    6) GitHub Actions workflow (Plan on PR, Apply on main with approvals)
    ----------------------------------------------------------------------

    Create .github/workflows/terraform.yml. This example uses OIDC and aws-actions/configure-aws-credentials.

        name: Terraform

        on:
            pull_request:
                types: [opened, synchronize, reopened]
            push:
                branches:
                    - main

        env:
            TERRAFORM_WORKING_DIR: .   # change if Terraform code in subfolder

        jobs:
            fmt-lint-scan:
                name: Lint & Security
                runs-on: ubuntu-latest
                steps:
                    - uses: actions/checkout@v4
                    - name: Setup Terraform
                      uses: hashicorp/setup-terraform@v2
                      with:
                        terraform_version: 1.5.0
                    - name: terraform fmt check
                       run: terraform -chdir=$TERRAFORM_WORKING_DIR fmt -check
                    - name: tflint
                        run: |
                            curl -sL https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash
                            tflint --version
                            tflint $TERRAFORM_WORKING_DIR
                    - name: tfsec
                        run: |
                            curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_tfsec.sh | bash
                            tfsec $TERRAFORM_WORKING_DIR || true

        plan:
            name: Terraform Plan
            runs-on: ubuntu-latest
            needs: fmt-lint-scan
            if: github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
            steps:
                - uses: actions/checkout@v4
                - name: Configure AWS credentials via OIDC
                  uses: aws-actions/configure-aws-credentials@v2
                  with:
                    role-to-assume: arn:aws:iam::123456789012:role/CI-Terraform-Role     # update
                    aws-region: eu-central-1
                - name: Setup Terraform
                  uses: hashicorp/setup-terraform@v2
                  with:
                    terraform_version: 1.5.0
                - name: Terraform Init
                   run: terraform -chdir=$TERRAFORM_WORKING_DIR init -input=false
                - name: Terraform Plan
                   run: terraform -chdir=$TERRAFORM_WORKING_DIR plan -out=tfplan -input=false
                - name: Save plan for comment
                  uses: actions/upload-artifact@v4
                  with:
                    name: tfplan
                    path: $TERRAFORM_WORKING_DIR/tfplan

        apply:
            name: Terraform Apply
            runs-on: ubuntu-latest
            needs: plan
            if: github.ref == 'refs/heads/main'
            environment:
                name: production          # Protect this environment in repo settings to require reviewers
            steps:
                - uses: actions/checkout@v4
                - name: Configure AWS credentials via OIDC
                  uses: aws-actions/configure-aws-credentials@v2
                  with:
                    role-to-assume: arn:aws:iam::123456789012:role/CI-Terraform-Role
                    aws-region: eu-central-1
                - name: Setup Terraform
                  uses: hashicorp/setup-terraform@v2
                  with:
                    terraform_version: 1.5.0
                - name: Download plan
                  uses: actions/download-artifact@v4
                  with:
                    name: tfplan
                    path: ${{ env.TERRAFORM_WORKING_DIR }}
                - name: Terraform Apply
                   run: terraform -chdir=$TERRAFORM_WORKING_DIR apply -input=false tfplan


    GitHub security notes
    ======================

    Protect the production environment in repo settings and require manual approvals / reviewers before the apply job runs.
    Make branch protection rules on main requiring code review, status checks (plan job), signed commits if desired.
    Use separate roles for plan and apply if you want to restrict forks from applying.

 7) GitLab CI pipeline (Plan on MR, Apply on protected branch with OIDC)
 =========================================================================

    Create .gitlab-ci.yml. GitLab’s OIDC token is exposed as $CI_JOB_JWT. We’ll exchange it for AWS creds via aws sts assume-role-with-web-identity.

    stages:
    - lint
    - plan
    - apply

    variables:
        TF_WORKING_DIR: "."
        AWS_REGION: "eu-central-1"
        ROLE_ARN: "arn:aws:iam::123456789012:role/CI-Terraform-Role" # set via variables or masked CI variable

    before_script:
        - apk add --no-cache curl jq python3 py3-pip bash || true
        - pip3 install awscli --upgrade --disable-pip-version-check
        - terraform --version || true

    lint:
        stage: lint
        image: hashicorp/terraform:1.5.0
        script:
            - terraform -chdir=$TF_WORKING_DIR fmt -check
            - wget -qO /usr/local/bin/tflint https://github.com/terraform-linters/tflint/releases/latest/download/tflint_linux_amd64
            - chmod +x /usr/local/bin/tflint
            - tflint || true
            - wget -qO /usr/local/bin/tfsec https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64
            - chmod +x /usr/local/bin/tfsec
            - tfsec || true

    .plan_template: &plan_template
        image: hashicorp/terraform:1.5.0
        stage: plan
        script:
            - echo "Exchanging GitLab JWT for AWS creds"
            - |
              aws sts assume-role-with-web-identity \
                --role-arn "$ROLE_ARN" \
                --role-session-name "gitlab-ci-terraform" \
                --web-identity-token "$CI_JOB_JWT" \
                --region "$AWS_REGION" > /tmp/awscreds.json
            - export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId' /tmp/awscreds.json)
            - export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' /tmp/awscreds.json)
            - export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken' /tmp/awscreds.json)
            - export AWS_DEFAULT_REGION=$AWS_REGION
            - terraform -chdir=$TF_WORKING_DIR init -input=false
            - terraform -chdir=$TF_WORKING_DIR plan -out=tfplan -input=false
        artifacts:
            paths:
                - $TF_WORKING_DIR/tfplan
            expire_in: 1h

    plan:
        <<: *plan_template
        only:
            - merge_requests

    apply:
        image: hashicorp/terraform:1.5.0
        stage: apply
        script:
            - echo "Exchanging GitLab JWT for AWS creds"
            - |
              aws sts assume-role-with-web-identity \
                --role-arn "$ROLE_ARN" \
                --role-session-name "gitlab-ci-terraform" \
                --web-identity-token "$CI_JOB_JWT" \
                --region "$AWS_REGION" > /tmp/awscreds.json
            - export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId' /tmp/awscreds.json)
            - export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' /tmp/awscreds.json)
            - export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken' /tmp/awscreds.json)
            - export AWS_DEFAULT_REGION=$AWS_REGION
            - terraform -chdir=$TF_WORKING_DIR init -input=false
            - terraform -chdir=$TF_WORKING_DIR apply -input=false tfplan
    only:
        - main
    when: manual


    GitLab security notes
    ======================

    Protect main and require approval (manual job) for apply.
    Keep ROLE_ARN in GitLab CI variables or hardcode if acceptable — avoid long-lived keys.
    Configure project settings to limit CI_JOB_JWT scope if possible.


 8) Additional automation & checks (recommended)
 ================================================

    Policy as code: Use Checkov, tfsec, or Open Policy Agent to enforce org policies.
    Pre-commit: Use pre-commit + pre-commit-terraform to run format/lint locally.
    Drift detection: schedule periodic terraform plan runs and alert on drift.
    State encryption & access: S3 with KMS, and careful KMS grants (allow role to use the key).
    Segregation: Separate Terraform state per environment (key = "env/proj/terraform.tfstate") and distinct IAM roles for each environment.
    Least privilege & role scoping: Narrow IAM resource ARNs; use iam:PassRole only where needed.
    Store secrets outside of tfvars: Use SSM Parameter Store or Secrets Manager and reference in Terraform (avoid embedding secrets in git).
    Remote runs & Terraform Cloud: Consider Terraform Cloud as alternative for remote runs, policy checks, state & sensitive values.


 9) Housekeeping & operational tips
 ====================================

    Use workspaces or separate directories for dev/staging/prod.
    Keep sensitive outputs marked sensitive = true.
    Use terraform validate and terraform init -backend-config=... in CI to ensure correct backend settings.
    Rotate your IAM roles and audit CloudTrail for AssumeRoleWithWebIdentity.
    Log S3/KMS/DynamoDB accesses for the state backend.


 10) Quick checklist before you run pipelines
 =============================================

    Created S3 bucket + DynamoDB table and configured encryption & versioning.
    Created an IAM role with OIDC trust policy for your CI provider.
    Attached a least-privilege policy allowing S3/DynamoDB for state + resource actions you need.
    Confirmed OIDC provider exists in AWS (GitHub/GitLab).
    Added role ARN to repo (GitHub Actions uses the role ARN in the action; GitLab uses CI variable ROLE_ARN).
    Protected main branch and required approvals for apply environment.
    Added terraform code and backend config to repo.
    Set up tflint/tfsec/checks.


 11) Troubleshooting common issues
 ===================================

    AccessDenied on S3 backend init: Confirm role has s3:ListBucket and s3:GetObject for bucket and s3:PutObject for key.
    OIDC assume fails: Check trust policy Principal matches the OIDC provider ARN and aud/sub claim conditions match your repo/branch.
    DynamoDB lock fails: Confirm role has the DynamoDB update/put/delete actions on the lock table.
    CI can't get token: Verify GitHub Actions actions/checkout and aws-actions/configure-aws-credentials usage, and GitLab CI CI_JOB_JWT is available.


 12) Where to go next (advanced)
 ================================

    Use multiple roles: role-plan (read-only for many resources + write state), role-apply (wider rights).
    Integrate secrets via Vault or AWS Secrets Manager with dynamic access in CI.
    Add cost estimation checks (in PRs) with infracost.
    Migrate to Terraform Cloud/Enterprise for remote runs, state locking, and policy enforcement at scale.