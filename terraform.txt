    TERRAFORM
    ==========
    It is an open-source infrastructure as code (IaC) tool that is used to define, provision, and manage infrastructure (servers, databases, networks etc.) across multiple cloud providers.

    Write configuration files : Terraform uses HCL (Hashicorp Configuration Language) to write configuration files.
    Run terraform commands : These commands utilize cofiguration files to create or update infrastructure automatically.

    Terraform takes care of:
    -------------------------
        What needs to be created
        What already exists
        What needs to be changed

#

    Why Terraform Is So Popular
    ----------------------------
    Feature	                    Description
    Cloud-agnostic	            Works with AWS, Azure, GCP, VMware, Oracle Cloud, etc.
    Declarative	                Define what you want, Terraform handles how
    Immutable Infrastructure	Replaces resources instead of patching them
    Version-controlled	        Configurations can be stored in Git
    Automation-friendly	        Works easily with CI/CD pipelines
    Extensible	                Thousands of providers and modules available

#

    Terraform Core Concepts — Overview Diagram
    ===========================================

    ┌────────────────────────────────────────┐
    │         Terraform Configuration        │
    │  (.tf files written in HCL)            │
    │  - Providers                           │
    │  - Resources                           │
    │  - Data Sources                        │
    │  - Variables                           │
    │  - Outputs                             │
    │  - Modules                             │
    └────────────────────────────────────────┘
                        │
                        ▼
    ┌────────────────────────────────────────┐
    │        Terraform State (.tfstate)      │
    │  Keeps track of real infrastructure    │
    │  → Used for Plan & Apply decisions     │
    └────────────────────────────────────────┘
                        │
                        ▼
    ┌────────────────────────────────────────┐
    │        Terraform CLI Workflow          │
    │  init → plan → apply → output → destroy│
    └────────────────────────────────────────┘


    Terraform Key Concepts
    =======================

    Concept	        Definition	                                                                Code                                                            Example Code	                                        Real-World Analogy
    Provider	    A plugin that tells Terraform how to interact with a cloud or service.      provider "<PROVIDER_NAME>" {                                    provider "aws" {                                        Think of a provider as the driver that allows Terraform to talk to a specific cloud (AWS, Azure, GCP).It exposes resources (like EC2, S3, VPC).
                                                                                                    <PROVIDER_ARGUMENTS>                                            alias  = "west"
                                                                                                    alias   = "<ALIAS_NAME>"                                        region = "us-west-2"
                                                                                                    version = "<VERSION_CONSTRAINT>"  # Deprecated                  }
                                                                                                    }
                                                                                                            

    Resource	    The basic building block — describes what you want to create or manage      resource "resource_type" "resource_name" {                      resource "aws_instance" "web" {                         Like specifying each item you want in your house — e.g., “1 sofa, 2 chairs”.
                    (VM, network, bucket, etc.).                                                    # Configuration settings for the resource
                                                                                                    attribute1 = value1                                             ami                   = "ami-a0cfeed8"
                                                                                                    attribute2 = value2                                             instance_type         = "t2.micro"
                                                                                                    # ...                                                           user_data             = file("init-script.sh")
                                                                                                }                                                                   tags = {
                                                                                                                                                                        Name = random_pet.name.id
                                                                                                                                                                    }
                                                                                                                                                                }
                    		
    Data Source	    Lets Terraform read information from existing resources (not managed by     data "provider_type" "name" {                                   data "aws_ami" "example" {                              Like looking up the latest furniture design before buying — you fetch existing data to make decisions.
                    Terraform) for use in your configurations.	                                    # Configuration options for the data source (filters)	        owners = ["amazon"]
                                                                                                }                                                                   filter {
                                                                                                                                                                        name   = "image-id"
                                                                                                                                                                        values = ["ami-abc123"]
                                                                                                                                                                    }
                                                                                                                                                                }

    Variable	    Inputs that make your configuration reusable and dynamic.	                variable "string_type" {	                                    variable "ami" {                                        Like filling out a form where you enter parameters (size, color) before ordering.
                                                                                                    description = "This is a variable of type string"               type        = string
                                                                                                    type        = string                                            description = "AMI ID for the EC2 instance"
                                                                                                    default     = "Default string value for this variable"          default     = "ami-0d26eb3972b7f8c96"
                                                                                                }                                                               }
    
    Output	        Displays specific values after deployment (e.g., IP address, resource ID).	output "<LABEL>" {	                                            output "instance_public_ip" {                           Like getting a receipt showing your order number after checkout.
                                                                                                    value       = <EXPRESSION>                                      description = "Public IP of EC2 instance"
                                                                                                    description = "<STRING>"                                        value       = aws_instance.web_server.public_ip
                                                                                                }                                                               }
    
    Module	        A reusable collection of Terraform resources that form a logical unit       module "<LABEL>" {                                              module "webservers" {                                   Like a blueprint you reuse to build identical rooms in different houses.
                    (e.g., a “VPC module” or “EC2 module”).		                                    source = "<location-of-module-files>"                           source = "../webservers"
                                                                                                    #...                                                        }
                                                                                                }

    State File (terraform.tfstate)	Terraform’s database — stores the current real-world        (auto-generated)	                                            (auto-generated)                                        Like a map or inventory of what’s currently deployed so Terraform knows what exists.
                state of resources it manages.	
    
    
    Backend	        Where the Terraform state file is stored — local by default,                backend "remote" {	                                            terraform {                                             Like choosing whether to store your project files on your local computer or in the cloud (Google Drive).
                    but can be remote (S3, GCS, Terraform Cloud).	                                organization = "example_corp"                                   backend "s3" {
                                                                                                    . . .                                                           bucket      = “MY_BUCKET”
                                                                                                }                                                                   key         = “PATH/TO/KEY”
                                                                                                                                                                    region      = “MY_REGION”
                                                                                                                                                                    access_key  = “AWS_ACCESS_KEY”
                                                                                                                                                                    secret_key  = “AWS_SECRET_KEY”
                                                                                                                                                                    }
                                                                                                                                                                }                                                                                                                                                                   

    Provisioner	    Used (sparingly) to run scripts or commands on a resource after             provisioner "remote-exec" {                                     resource "aws_instance" "web" {                         Like adding custom finishing touches after building (e.g., installing curtains).
                                                                                                    inline = ["sudo apt update"]                                    # ...
                                                                                                    }	                                                            provisioner "local-exec" {
                    it’s created.	                                                                                                                                    command = "echo The server's IP address is ${self.private_ip}"
                                                                                                                                                                    }
                                                                                                                                                                }                


    Dependency Graph	Terraform automatically figures out the order of operations             resource "aws_vpc" "main" {...}                                                                                         Like assembling furniture — Terraform knows it must build the table before placing the lamp on it.
                        based on resource references.                                               resource "aws_subnet" "sub" {
                                                                                                    vpc_id = aws_vpc.main.id
                                                                                                    }	
                    	

    Plan	        Shows what Terraform will do — a “dry run” before making changes.	        terraform plan	            Like reviewing your shopping list before placing the order.
    Apply	        Executes the plan — creates, updates, or deletes infrastructure.	        terraform apply	            Like actually ordering the items from your list.
    Destroy	        Deletes all resources defined in the configuration.	                        terraform destroy	        Like canceling your order and returning everything.

#

    Terraform Workflow Overview (Diagram)
    ======================================

    ┌────────────────────────────┐
    │   1. Write Configuration   │
    │   (.tf files in HCL)       │
    └─────────────┬──────────────┘
                    │
                    ▼
    ┌────────────────────────────┐
    │   2. Initialize Project    │
    │   terraform init           │
    └─────────────┬──────────────┘
                    │
                    ▼
    ┌────────────────────────────┐
    │   3. Plan Changes          │
    │   terraform plan           │
    └─────────────┬──────────────┘
                    │
                    ▼
    ┌────────────────────────────┐
    │   4. Apply Configuration   │
    │   terraform apply          │
    └─────────────┬──────────────┘
                    │
                    ▼
    ┌────────────────────────────┐
    │   5. Verify & Output       │
    │   terraform output         │
    └─────────────┬──────────────┘
                    │
                    ▼
    ┌────────────────────────────┐
    │   6. Destroy (optional)    │
    │   terraform destroy        │
    └────────────────────────────┘

#

    Step-by-Step Terraform Workflow Table
    ======================================

    Step	                            Command	            Purpose / Explanation	                                
    1. Write Configuration	            (no command)	    Define infrastructure in .tf files using HCL (HashiCorp Configuration Language). This is the desired state.	
    2. Initialize the Working Directory	terraform init	    Downloads the necessary providers (e.g., AWS, Azure) and initializes backend configuration for state management.	
    3. Validate Configuration	        terraform validate	Checks that your .tf files are syntactically correct and internally consistent.	
    4. Format Configuration (Optional)	terraform fmt	    Automatically formats all .tf files for readability and consistency.	
    5. Create an Execution Plan	        terraform plan	    Compares the current state with the configuration and shows the changes that will be made — but doesn’t apply them yet.	
    6. Apply the Configuration	        terraform apply	    Executes the plan — creates or modifies resources to match your configuration. Prompts for confirmation before applying.	
    8. Output Values (Optional)	        terraform output	Displays values defined as outputs in your code (like IPs, resource IDs, etc.).	
    9. Manage State (Optional)	        terraform state     list / terraform state show	View or inspect specific resources tracked in the state file.	
    10. Destroy Infrastructure	        terraform destroy	Destroys all resources managed by Terraform (useful for test environments).	

#

    Common Terraform Directory Structures
    ======================================
    Let’s go through the 4 most widely used structures, what they’re used for, and their pros/cons — with clear diagrams.


1. Flat Structure (Basic / Small Projects)
-------------------------------------------

    Best for: small single-environment projects (like a personal AWS sandbox or proof of concept)

        terraform-project/
        ├── main.tf
        ├── variables.tf
        ├── outputs.tf
        └── terraform.tfvars

    Description:
    -------------
    All resources and configurations live in one directory.
    Quick to start and simple to manage.
    Hard to scale — doesn’t separate environments or modules.

    Pros:
    -----
    Simple and beginner-friendly
    Great for demos or single-resource deployments

    Cons:
    -----
    No separation of environments
    Repetition when scaling


2. Environment-Based Structure
-------------------------------

    Best for: teams managing multiple environments (dev, qa, prod) with similar infrastructure.

        terraform/
        ├── modules/
        │   ├── network/
        │   │   ├── main.tf
        │   │   └── variables.tf
        │   └── compute/
        │       ├── main.tf
        │       └── variables.tf
        └── envs/
            ├── dev/
            │   ├── main.tf
            │   ├── variables.tf
            │   └── terraform.tfvars
            ├── qa/
            │   ├── main.tf
            │   ├── variables.tf
            │   └── terraform.tfvars
            └── prod/
                ├── main.tf
                ├── variables.tf
                └── terraform.tfvars

    Description:
    -------------
    Each environment (dev, qa, prod) uses the same modules but with different variables.
    Keeps infra consistent across stages.
    Allows independent state files per environment.

    Pros:
    -----
    Clean separation of environments
    Shared, reusable modules
    Easier state management

    Cons:
    -----
    Slightly more complex structure
    Need to maintain multiple .tfvars files


3. Layered / Component-Based Structure
---------------------------------------

    Best for: large enterprises where infrastructure is split into independent layers or stacks (network, compute, database, security)

        terraform/
        ├── global/
        │   └── s3_backend/
        ├── network/
        │   ├── main.tf
        │   └── variables.tf
        ├── compute/
        │   ├── main.tf
        │   └── variables.tf
        ├── database/
        │   ├── main.tf
        │   └── variables.tf
        └── security/
            ├── main.tf
            └── variables.tf

    Description:
    ------------
    Each directory is a self-contained Terraform “layer”.
    Allows deploying or destroying individual layers independently.
    Often used with remote state data sharing (e.g., network exports VPC ID to compute).

    Pros:
    -----
    Modular and scalable
    Clear boundaries between infrastructure layers
    Easier to manage complex org structures

    Cons:
    -----
    Requires good coordination between layers
    Remote state management can get tricky


4. Monorepo with Modules + Workspaces (Advanced Setup)
-------------------------------------------------------
    
    Best for: organizations using Terraform Cloud / Enterprise or CI/CD pipelines

        terraform/
        ├── modules/
        │   ├── vpc/
        │   ├── ec2/
        │   └── rds/
        └── main/
            ├── main.tf
            ├── variables.tf
            └── backend.tf

    Terraform Workspaces are used for each environment:

        terraform workspace new dev
        terraform workspace new prod
        terraform workspace select dev

    Description:
    ------------
    Single directory manages all environments using workspaces.
    Shared code, but environment variables define behavior.

    Pros:
    -----
    Single source of truth
    Great for automation pipelines
    Minimal duplication

    Cons:
    -----
    Harder to manage state manually
    Workspaces can get confusing in large teams

Bonus: Hybrid Pattern (Best of Both Worlds)
-------------------------------------------
    Common in mature DevOps teams

    terraform/
    ├── modules/
    │   ├── networking/
    │   ├── compute/
    │   └── monitoring/
    ├── envs/
    │   ├── dev/
    │   ├── staging/
    │   └── prod/
    └── backend/
        └── main.tf

    Description:
    ------------
    Uses modules for reusable infra patterns.
    Uses environments for configuration isolation.
    Can optionally add layers for different domains (network, app, data).

    Best Practice Setup
    --------------------
    modules/ → reusable code
    envs/ → environment-specific settings
    backend/ → remote state management (e.g., S3 + DynamoDB)

#

    INSTALL TERRAFORM
    ==================

    https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli

    sudo apt-get update && sudo apt-get install -y gnupg software-properties-common
    wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg > /dev/null
    gpg --no-default-keyring --keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg --fingerprint
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(grep -oP '(?<=UBUNTU_CODENAME=).*' /etc/os-release || lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
    sudo apt update
    sudo apt-get install terraform

#

    Why Terraform Version Differences Matter
    ========================================

    Terraform evolves quickly - new versions often:

    Change syntax or language features (HCL updates)
    Modify provider behavior (like AWS provider)
    Alter how state is stored or interpreted
    Update dependency resolution or module handling

    So, if one person uses Terraform 1.3.0 and another uses 1.7.5, the same configuration might plan or apply differently — leading to drift or even failed deployments.

    Common Problems Caused by Version Mismatch
    -------------------------------------------

    Issue	                        Example	                                                                                    Impact
    ------                          --------                                                                                    -------
    State Incompatibility	        Terraform 0.14 state files might not be compatible with Terraform 1.6	                    One user’s “plan” command fails or produces unexpected diffs
    Syntax Changes	                Older versions don’t support new block types like for_each, depends_on, or dynamic blocks	Configs fail to load on older versions
    Provider Locking Differences	Terraform ≥0.14 uses .terraform.lock.hcl for provider version locks	                        Teams on older versions might install different provider versions
    Backend/Remote State Updates	Newer Terraform may add or rename backend arguments	                                        State upload/download fails or corrupts
    Module Compatibility	        Modules written for Terraform 1.6 may not work on 0.13 (due to dependency handling)	        Module registry errors or missing outputs
    CLI Behavior Changes	        Command flags like terraform init -upgrade behave differently across versions	            Inconsistent pipeline results


    How to Prevent Version Conflicts
    =================================

1.Pin the Terraform Version in Configuration
---------------------------------------------
    
    Add this block to your Terraform code:
    
    terraform {
        required_version = "~> 1.6.0"
        }

    Meaning:

        Works with Terraform 1.6.x
        Fails with Terraform 1.7 or below 1.6

    You can even enforce stricter control:

    terraform {
        required_version = "= 1.7.5"
        }


2.Pin Provider Versions Too
----------------------------

    Always lock providers (like AWS, Azure, GCP):

    terraform {
        required_providers {
            aws = {
            source  = "hashicorp/aws"
            version = "~> 5.0"
            }
        }
    }

    Terraform stores exact versions in .terraform.lock.hcl — commit this file to Git so everyone uses the same provider builds.


3.Use Version Managers
-----------------------

    Use tools like "tfenv" or "asdf" to manage multiple Terraform versions easily.

    Example (with tfenv):

        tfenv install 1.7.5
        tfenv use 1.7.5

4.Standardize Versions in CI/CD Pipelines
------------------------------------------

    In Jenkins, GitLab, or GitHub Actions, specify the Terraform version explicitly in the pipeline image or script.

    Example (GitHub Actions):

        - name: Setup Terraform
          uses: hashicorp/setup-terraform@v3
          with:
            terraform_version: 1.7.5


5.Avoid Upgrading Mid-Project Without Planning
-----------------------------------------------
    If you must upgrade Terraform versions:

    1.Review the Terraform upgrade guides
    2.Run:

        terraform init -upgrade

    3.Review the "terraform plan" carefully
    4.Update required_version and re-test before merging


    Summary Table
    --------------

    Problem Area	            Cause	                                        Fix
    -------------               ------                                          ----
    Syntax errors	            Old Terraform doesn’t understand new features	Use required_version block
    State corruption	        State format changed	                        Upgrade carefully using terraform init -upgrade
    Provider mismatches	        Auto-upgraded provider versions	                Use .terraform.lock.hcl
    CI/CD inconsistency	        Different runner images	                        Pin Terraform version in pipeline
    Local developer drift	    Different local versions	                    Use tfenv or asdf

#

    PROVIDERS
    ==========

    A Terraform provider is a plugin that allows Terraform to interact with a specific cloud platform, service, or API.
    Each provider defines resources (things you can create/manage) and data sources (things you can read/import)

    Provider Structure in Terraform
    --------------------------------

    Providers are defined inside a terraform block and configured using a provider block.

    terraform {
        required_providers {
            aws = {
                source  = "hashicorp/aws"
                version = "~> 5.0"
            }
        }
    }

    provider "aws" {
        region  = "eu-central-1"
        profile = "default"
    }

    Multiple Providers Example
    ---------------------------
    
    You can use more than one provider in a single project (e.g., AWS + Azure).

    terraform {
        required_providers {
            aws = {
                source  = "hashicorp/aws"
                version = "~> 5.0"
            }
            azurerm = {
                source  = "hashicorp/azurerm"
                version = "~> 4.0"
            }
        }
        }

        provider "aws" {
            region = "us-east-1"
        }

        provider "azurerm" {
            features {}
        }

    Provider Aliasing (Multiple Configurations of Same Provider)
    -------------------------------------------------------------

    If you want to deploy to multiple AWS regions or different accounts, you can use aliases.

    provider "aws" {
        region = "us-east-1"
    }

    provider "aws" {
        alias  = "frankfurt"
        region = "eu-central-1"
    }

    resource "aws_instance" "us_server" {
        ami           = "ami-0abcd1234"
        instance_type = "t2.micro"
    }

    resource "aws_instance" "eu_server" {
        provider      = aws.frankfurt
        ami           = "ami-0abcd5678"
        instance_type = "t2.micro"
    }

    Provider Version Management
    ---------------------------

    To avoid version drift between teams or CI/CD:

        Pin versions in required_providers
        Lock dependencies with .terraform.lock.hcl

    Example:
    terraform {
        required_providers {
            aws = {
                source  = "hashicorp/aws"
                version = "= 5.33.0"
            }
        }
    }

    Run:

    terraform init

    Terraform will download that exact version and record it in .terraform.lock.hcl.

#

    VARIABLES
    ==========

    A variable in Terraform is an input parameter that allows you to pass dynamic values into your configuration.
    Instead of hardcoding values (like region names, instance types, or IP ranges), you define variables and reference them throughout your code.

    Why Variables Are Important
    ----------------------------
    Purpose	            Benefit
    --------            --------
    Avoid hardcoding	You don’t repeat or expose sensitive values in code
    Reusability	        One configuration works across multiple environments
    Flexibility	        Modify behavior via .tfvars or CLI
    Security	        Use environment variables for secrets
    Automation	        Easy integration with CI/CD pipelines

    Declaring Variables
    --------------------
    Variables are declared in a variables.tf file (conventionally), using the variable block.
    Example:

    variable "region" {
        description = "AWS region where resources will be deployed"
        type        = string
        default     = "eu-central-1"
    }

    Referencing Variables
    ----------------------
    Once declared, you use them anywhere in your Terraform configuration like this:

    provider "aws" {
        region = var.region
    }

    Terraform replaces var.region with the actual value (from default or user input).


    Variable Types
    ===============
    Terraform supports several data types:

    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    | **Type**                 | **Description**                                                              | **Example Declaration**                                                        | **Example Value**                                                       | **Notes / Rules / Exceptions**                                                                                                                                          |
    | ------------------------ | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | **string**               | A sequence of characters. Used for textual data like names, regions, or IDs. | `variable "region" { type = string }`                                          | `"eu-central-1"`                                                        | - (a) Must be enclosed in quotes. (b) Interpolation allowed: `"Instance type is ${var.type}"`.                                                                          |
    | **number**               | Represents numeric values (integer or float).                                | `variable "instance_count" { type = number }`                                  | `3` or `3.5`                                                            | - (a) Can be used in arithmetic expressions. (b) Terraform auto-converts numeric-looking strings (e.g. `"3"`) **only in legacy HCL1**, not in modern HCL2.              |
    | **bool**                 | Represents boolean values (`true` or `false`).                               | `variable "enable_logging" { type = bool }`                                    | `true`                                                                  | - (a) Useful for conditional logic (`count = var.enable_logging ? 1 : 0`).                                                                                              |
    | **list(<type>)**         | Ordered collection of items, all of the same type.                           | `variable "availability_zones" { type = list(string) }`                        | `["eu-central-1a", "eu-central-1b"]`                                    | - (a) Index starts at 0. (b) Access using index: `var.availability_zones[0]`. (c) All elements must match declared type.                                                |
    | **set(<type>)**          | Unordered collection of unique items of the same type.                       | `variable "tags" { type = set(string) }`                                       | `["app", "backend", "app"]`                                             | - (a) Duplicate items are **automatically removed**. (b) Cannot access by index (no order guaranteed).                                                                  |
    | **map(<type>)**          | Key-value pairs, all values must be the same type.                           | `variable "instance_tags" { type = map(string) }`                              | `{ Name = "web", Environment = "prod" }`                                | - (a) Access using key: `var.instance_tags["Environment"]`. (b) Keys must be unique strings.                                                                            |
    | **object({...})**        | Collection of named attributes with specific types.                          | `variable "server" { type = object({ name = string, size = number }) }`        | `{ name = "app-server", size = 2 }`                                     | - (a) Like a struct in programming. (b) All defined attributes are **required** unless default provided.                                                                |
    | **tuple([<types>])**     | Ordered collection with fixed types per position.                            | `variable "config" { type = tuple([string, number, bool]) }`                   | `["web", 2, true]`                                                      | - (a) Each element can have a different type. (b) Length and type order are fixed.                                                                                         |
    | **any**                  | Accepts any value of any type.                                               | `variable "dynamic_input" { type = any }`                                      | `"test"` or `[1,2,3]` or `{a="b"}`                                      | - (a) Most flexible but least strict. (b) Use only when you truly need untyped input.<br>- Not recommended for production IaC (reduces validation safety).                 |
    | **null**                 | Represents an undefined or intentionally empty value.                        | `variable "description" { default = null }`                                    | `null`                                                                  | - (a) Acts as “unset” — Terraform uses default or removes field. (b) Commonly used to override defaults in modules.                                                        |
    | **complex/nested types** | Combination of types (list of maps, map of objects, etc.).                   | `variable "servers" { type = list(object({ name = string, size = string })) }` | `[ { name = "web", size = "small" }, { name = "db", size = "large" } ]` | - (a) Fully supports deep nesting.<br>- Enforces type safety across structures. (b) Must match structure exactly or validation fails.                                      |
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    Assigning Variable Values
    ==========================
    Terraform supports several ways to provide values for variables.

    Method	                    Command/Example	                                When to Use
    -------                     ----------------                                ------------
    Default value	            Defined in variable block	                    Simple or constant values
    Command-line flag	        terraform apply -var="region=us-east-1"	        Quick tests or overrides
    Variable file (.tfvars)	    terraform apply -var-file="dev.tfvars"	        Common in environments
    Environment variable	    export TF_VAR_region=us-east-1	                Good for CI/CD
    Interactive input	        Terraform prompts you if no default is given	Manual runs

    Assigning Values to Variables
    ------------------------------
    Terraform supports five main ways to assign variable values.
    If multiple are used, Terraform follows a specific precedence order (see next section).

    Method	                    How to Use	                                            Example
    -------                     -----------                                             --------
    1. Default value	        Defined in variable block	                            default = "eu-central-1"
    2. .tfvars file	Values      file (e.g. dev.tfvars)	                                region = "us-east-1"
    3. Command-line flag	    Using -var or -var-file	                                terraform apply -var="region=us-east-1"
    4. Environment variable	    Prefixed with TF_VAR_	                                export TF_VAR_region=us-east-1
    5. Interactive prompt	    Terraform asks for value if not provided elsewhere	    region (string):


    Automatically Loaded
    ---------------------
    Following variable files will be loaded automatically by Terraform, files with any other name will be required in commandline.

    terraform.tfvars
    terraform.tfvars.json
    *.auto.tfvars
    *.auto.tfvars.json

    For eg. 
    
    terraform apply                                 // If variables are in a file with name as mentioned above then only run the command and terraform will pick the values.
    terraform apply -var-file variables.tfvars      // Different filename needs to be mentioned along with the command.    


    Variable Definition Precedence
    -------------------------------
    Variable precedence (or load order) directly affects how Terraform resolves conflicting values.

    Terraform Variable Definition Precedence (Lowest → Highest Priority)
    Priority	                    Source	                                                        Description / Behavior
    Default values	                Values set in the variable block using default	                Used only if no other value is supplied anywhere else.
    Environment variables	        Environment variables of the form TF_VAR_<variable_name>	    Example: export TF_VAR_region=us-east-1. Overrides defaults in code.
    terraform.tfvars file	        A file named exactly terraform.tfvars (auto-loaded)	            Automatically loaded if present in the working directory.
    *.auto.tfvars files	            Any files ending with .auto.tfvars or .auto.tfvars.json	        Auto-loaded alphabetically by filename. Useful for separating environment configs.
    -var-file flag	                Values passed explicitly via CLI using -var-file	            Example: terraform apply -var-file="dev.tfvars". Overrides all auto-loaded files.
    -var flag	                    Direct variable values passed through CLI	                    Example: terraform apply -var="region=us-west-2". Has the highest precedence among all file- or env-based inputs.
    Interactive input	            Terraform will prompt for input if no value is found anywhere	Used only as a last resort — if no default, no tfvars, no CLI, and no env var exist.


    Precedence Summary (Bottom → Top Wins)
    ---------------------------------------
    Default (lowest)
    ↓
    Environment variables
    ↓
    terraform.tfvars
    ↓
    *.auto.tfvars / *.auto.tfvars.json
    ↓
    -var-file (explicit)
    ↓
    -var (explicit CLI)
    ↓
    Prompted input (if nothing else)


    Special Notes / Edge Cases
    ---------------------------
    Case	                                            Behavior
    -----                                               --------
    If multiple *.auto.tfvars files exist	            Loaded alphabetically — later files can override earlier ones.
    If both .tfvars and .tfvars.json exist	            Both are loaded, JSON parsed automatically.
    If variable not found anywhere	                    Terraform will prompt for input unless marked nullable = false.
    If variable marked sensitive	                    Value hidden from CLI output, but precedence rules stay the same.
    If variable type mismatched	                        Terraform will fail at plan time, even if value has highest precedence.


    REFERENCE EXPRESSIONS
    ======================

    A reference expression in Terraform is a way to access the value of another object (variable, resource, data source, local, module output, etc.) within your configuration.
    A reference expression lets you refer to a value that’s defined somewhere else in your Terraform code.

    General Reference Expression Format
    ------------------------------------

    The general syntax is:
    <ADDRESS>.<ATTRIBUTE>

    Part	        Meaning
    <ADDRESS>	    Refers to a specific Terraform object (variable, resource, data, etc.)
    <ATTRIBUTE>	    Refers to a specific property or output of that object

    Types of Reference Expressions
    -------------------------------
    Category	                    Syntax Example	                    Description
    ---------                       ---------------                     -------------
    Variable	                    var.region	                        Refers to a user-defined input variable
    Local value	                    local.app_name	                    Refers to a local value defined in locals {} block
    Resource	                    aws_instance.web.id	                Refers to an attribute of a resource (e.g., its ID)
    Data source	                    data.aws_ami.ubuntu.id	            Refers to data fetched from an external source
    Module output	                module.network.vpc_id	            Refers to output from another module
    Terraform built-in functions	upper(var.name)	                    Uses function output as a reference
    Count or For-Each reference	    aws_instance.web[count.index].id	Refers to dynamically created instances
    Self reference	                self.id (inside resource block)	    Refers to the resource itself (used in provisioners)

    Examples of Reference Expressions
    ----------------------------------
 
 1.Referencing Variables

    variable "region" {
        default = "eu-central-1"
    }

    provider "aws" {
        region = var.region
    }

    → var.region references the value of the variable region.


 2.Referencing Resource Attributes

    resource "aws_vpc" "main" {
        cidr_block = "10.0.0.0/16"
    }

    resource "aws_subnet" "web" {
        vpc_id     = aws_vpc.main.id
        cidr_block = "10.0.1.0/24"
    }

    → aws_vpc.main.id references the ID output from the VPC resource.


 3.Referencing Data Source Outputs

    data "aws_ami" "ubuntu" {
        most_recent = true
        owners      = ["099720109477"]
        filter {
            name   = "name"
            values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
        }
    }

    resource "aws_instance" "web" {
        ami           = data.aws_ami.ubuntu.id
        instance_type = "t2.micro"
    }

    → data.aws_ami.ubuntu.id refers to the AMI ID fetched by the data source.


 4.Referencing Module Outputs

    module "network" {
        source = "./modules/network"
    }

    resource "aws_instance" "web" {
        subnet_id = module.network.subnet_id
    }

    → module.network.subnet_id refers to the output from the network module.


 5.Using Locals
    locals {
        app_name = "myapp"
        env      = "prod"
    }

    resource "aws_s3_bucket" "app" {
        bucket = "${local.app_name}-${local.env}-bucket"
    }

    → local.app_name and local.env are local references that simplify repeated logic.


 6.Using Count or For-Each

    resource "aws_instance" "web" {
        count         = 2
        ami           = "ami-12345"
        instance_type = "t2.micro"
        tags = {
            Name = "web-${count.index}"
        }
    }

    output "instance_ids" {
        value = aws_instance.web[*].id
    }

    → count.index refers to the current index in the loop.
    → aws_instance.web[*].id collects all IDs from multiple instances.


    How Terraform Evaluates References
    -----------------------------------
    Terraform builds a dependency graph from reference expressions.
    It ensures that resources are created in the correct order based on these dependencies.

    For example:
    aws_subnet.web depends on aws_vpc.main

    Because it references aws_vpc.main.id. Terraform knows it must:

    Create the VPC first
    Then create the subnet

    This is what makes Terraform declarative — it figures out the correct execution order automatically.


    Best Practices for Using Reference Expressions
    -----------------------------------------------
    Do’s	                                                                    Don’ts
    -----                                                                       -------
    Use explicit references instead of depends_on whenever possible	            Don’t hardcode resource IDs or names
    Use for_each for clarity when mapping logical resources	                    Avoid overly nested references that reduce readability
    Use locals for computed values reused across resources	                    Avoid circular references between resources
    Reference module outputs rather than resources inside the module	        Don’t mix count and for_each in the same block

#

    RESOURCE DEPENDENCY 
    ====================

    Resource dependency in Terraform means that one resource depends on another resource’s existence, attribute, or output before it can be created or updated.
    Terraform uses these dependencies to automatically build a dependency graph, which determines the correct order to apply, modify, or destroy resources.

    How Terraform Determines Dependencies
    --------------------------------------
    Terraform identifies dependencies in two ways:

    Type	                    Description	                                                                            Example
    -----                       ------------                                                                            --------
    Implicit Dependency	        Automatically inferred when one resource references another resource’s attribute.	    subnet uses vpc.id
    Explicit Dependency	        Manually declared using depends_on meta-argument.	                                    depends_on = [aws_vpc.main]

#

 1.Implicit Dependency
 ----------------------
    Terraform automatically recognizes dependencies when one resource references another’s attributes.

    Example
    --------
    
    resource "aws_vpc" "main" {
        cidr_block = "10.0.0.0/16"
    }

    resource "aws_subnet" "web" {
        vpc_id     = aws_vpc.main.id  # <--- creates an implicit dependency
        cidr_block = "10.0.1.0/24"
    }


    Explanation:

    The aws_subnet.web resource depends on the aws_vpc.main resource.
    Terraform automatically knows to create the VPC first, then the subnet.
    You don’t have to specify depends_on manually here — Terraform figures it out through the reference.


 2.Explicit Dependency
 ----------------------

    Sometimes you need to force Terraform to wait for one or more resources to finish before starting another — even if no direct attribute reference exists.

    You do that with the depends_on meta-argument.

    Example
    --------
    
    resource "aws_s3_bucket" "app_bucket" {
        bucket = "my-app-bucket"
    }

    resource "aws_iam_role" "lambda_exec" {
        name = "lambda_execution_role"
    }

    resource "aws_lambda_function" "processor" {
        function_name = "data-processor"
        role          = aws_iam_role.lambda_exec.arn
        handler       = "index.handler"
        runtime       = "nodejs18.x"
        filename      = "lambda.zip"

        depends_on = [
            aws_s3_bucket.app_bucket  # <--- explicit dependency
        ]
    }


    Explanation:

    The Lambda doesn’t directly reference the bucket.
    But you still want to make sure the bucket exists first (perhaps it uploads the Lambda code after creation).
    depends_on explicitly forces Terraform to create the S3 bucket first.

    Dependency Behavior
    --------------------
    Action	                        Terraform Behavior
    ------                          -------------------
    Apply (terraform apply)	        Creates resources in dependency order
    Destroy (terraform destroy)	    Destroys in reverse dependency order
    Plan (terraform plan)	        Displays operations in dependency-resolved sequence
    Change in dependency	        Terraform refreshes dependent resources automatically

    Best Practices
    ---------------
    Do’s	                                                                                            Don’ts
    -----                                                                                               -------
    Prefer implicit dependencies — Terraform can detect these automatically	                            Avoid unnecessary depends_on — can make plans slower and more complex
    Use depends_on only for resources without direct references (e.g., null resources, provisioners)	Don’t create circular dependencies (A → B → A)
    Visualize dependency graph with terraform graph	                                                    Don’t rely on creation order if dependencies are unclear
    Keep dependencies clean to simplify lifecycle management	                                        Avoid indirect dependencies through string interpolation ("${...}") unless needed


    Commands Related to Dependencies
    ---------------------------------
    Command	                Description
    -------                 ------------
    terraform plan	        Shows dependency-resolved sequence of resource actions
    terraform apply	        Executes changes in dependency order
    terraform destroy	    Destroys resources in reverse dependency order
    terraform graph	        Outputs a DOT-format dependency graph that can be visualized (e.g., with Graphviz)

    Example:

    terraform graph | dot -Tpng > graph.png

    → Generates a visual diagram of your resource dependencies.

    
    OUTPUT VARIABLES
    =================

    An output variable in Terraform is a named value that is returned after Terraform finishes applying a configuration.
    It’s how Terraform exposes useful information — like IP addresses, ARNs, IDs — to users or other configurations (modules).

    Purpose of Output Variables
    ----------------------------
    Purpose	                        Description	                                                                        Example
    --------                        ------------                                                                        --------
    Display info after apply	    Show key resource info (like instance IPs) on screen after terraform apply	        Public IP of an EC2 instance
    Share data between modules	    Pass outputs from one module to another	                                            VPC ID output from a network module
    Expose values for automation	Let other tools or scripts (like CI/CD pipelines) read important Terraform data	    Read outputs via terraform output -json


    Basic Syntax
    -------------
    Defined using the output block:

    output "<name>" {
        value = <expression>
    }


    Outputs and State
    ------------------

    Terraform stores outputs in the state file (terraform.tfstate).
    This means outputs reflect the current known values of your resources.
    If you modify or delete a resource, its outputs update automatically.

    Example — Full Workflow
    ------------------------

    # main.tf

    provider "aws" {
        region = "eu-west-1"
    }

    resource "aws_instance" "example" {
        ami           = "ami-123456"
        instance_type = "t2.micro"
    }

    output "example_instance_id" {
        description = "The EC2 instance ID"
        value       = aws_instance.example.id
    }

    output "example_public_ip" {
        value = aws_instance.example.public_ip
    }


    Run Commands
    terraform init
    terraform apply
    terraform output


    Output:

    example_instance_id = "i-0f24aa0b2b8c2eabc"
    example_public_ip   = "3.123.45.67"



    Best Practices
    ---------------
    Do’s	                                        Don’ts
    -----                                           -------
    Use descriptive names and add description	    Avoid generic names like “output1”
    Mark secrets as sensitive = true	            Don’t print passwords or keys in plain text
    Use outputs to connect modules cleanly	        Don’t hardcode values across modules
    Use terraform output -json for automation       Don’t depend on console output for scripts


#

    TERRAFORM STATE FILE
    =====================

    The state file (terraform.tfstate) is Terraform’s local database that records the current real-world state of all resources Terraform manages. 
    It maps HCL configuration to actual cloud provider objects (IDs, attributes, metadata) so Terraform can plan and apply changes correctly.

    Why it matters
    ---------------
        Source of truth for Terraform’s plan/apply operations.
        Tracks resource IDs, attributes, dependencies, and metadata.
        Enables incremental updates (Terraform knows what already exists).
        Holds outputs and computed values used across resources & modules.

    Where it lives
    ---------------
        Local (default): ./terraform.tfstate in working directory.
        Remote backends (recommended for teams): S3, Azure Storage, Google Cloud Storage, Terraform Cloud, etc. Remote backends centralize state, support locking, and store backups.

        Example S3 backend (recommended pattern):

        terraform {
            backend "s3" {
                bucket         = "my-terraform-state-bucket"
                key            = "envs/prod/terraform.tfstate"
                region         = "eu-central-1"
                dynamodb_table = "terraform-locks"   # for state locking
                encrypt        = true
            }
        }

    State file format
    ------------------
        JSON.
        Contains resources, modules, outputs, provider info and metadata.
        Terraform also creates a backup terraform.tfstate.backup automatically on changes.

    Locking & concurrency
    ----------------------
    State locking prevents concurrent apply operations that could corrupt state.
    For S3 backend use DynamoDB table for locks (dynamodb_table in backend config).
    Terraform Cloud and many managed backends provide automatic locking.

    Security & sensitive data
    --------------------------
    State may contain secrets (DB passwords, access tokens) and full resource attributes.
    Protect access: use remote backend with encryption, restrict IAM, enable SSE for S3, and limit who can read state.
    Treat terraform.tfstate as sensitive: do NOT commit to Git.

    Common operations / CLI commands
    ---------------------------------

    View providers & CLI version

        terraform version


    View state resources list

        terraform state list


    Show attributes for one resource

        terraform state show aws_instance.web


    Pull state (download current remote state to stdout)

        terraform state pull > state.json


    Push state (dangerous — pushes a state file to configured backend)

        terraform state push state.json


    Move a resource within state (rename or refactor)

        terraform state mv module.old.aws_instance.web module.new.aws_instance.web


    Remove a resource from state (keep cloud resource untouched)

        terraform state rm aws_instance.old


    Import existing resource into state

        terraform import aws_instance.web i-0abcd1234


    Replace provider reference (e.g., after provider source changes)

        terraform state replace-provider registry.terraform.io/-/oldname registry.terraform.io/hashicorp/newname


    Graph / visualize dependencies

        terraform graph | dot -Tpng > graph.png             // install


    Show raw state (not recommended on shared environments unless secure)

        terraform state pull


    Typical workflows & examples
    -----------------------------

 1. Move resource after renaming module

    Update HCL (new module path/name).

    Run:

        terraform state mv module.old.aws_instance.web module.new.aws_instance.web
        terraform plan

    This avoids resource recreation.


 2. Remove a resource from Terraform management

    If a resource must remain but you want Terraform to stop managing it:

        terraform state rm aws_db_instance.legacy

    Terraform will no longer track it; it won’t attempt to delete it on future runs.


 3. Import an existing resource

    To bring manually created resources under Terraform control:

    terraform import aws_s3_bucket.bucket my-bucket-name
    terraform plan

    Then add the matching resource block to code.


    Best practices (practical checklist)
    -------------------------------------

        Use a remote backend (S3 + DynamoDB, Azure Storage, GCS or Terraform Cloud) for team work.
        Enable state locking to prevent concurrent applies.
        Encrypt state at rest and restrict IAM permissions to read/write.
        Never commit terraform.tfstate or .backup to version control.
        Commit .terraform.lock.hcl to lock provider versions.
        Use workspaces sparingly — prefer separate state files per environment for clarity.
        Regularly backup state or rely on backend versioning (S3 versioning).
        Use terraform plan and review changes before apply.
        Avoid manual edits to state JSON; use terraform state CLI or mv/rm commands.
        Mark sensitive outputs and limit their exposure; consider remote secret storage.


    Troubleshooting tips
    ---------------------

        If plan shows unexpected replacements: check provider versions, .terraform.lock.hcl, and drift in actual resource attributes.
        If state is corrupted or you need to rollback: use the automatic terraform.tfstate.backup or backend versioning to restore a previous copy, then terraform refresh and plan.
        To recover from concurrent modification: check backend lock (DynamoDB), inspect who locked it, and coordinate team to release or wait.


    When you might edit state manually
    -----------------------------------

    Rare scenarios only (and be careful):
        Removing a stale resource entry that no longer exists anywhere and you want Terraform to forget it (state rm preferred).
        Complex refactor where terraform state mv cannot express the change (still prefer state mv).
        If you must edit JSON, backup first, and validate with terraform plan immediately.


    Short example: S3 backend with locking (recommended)
        terraform {
            required_version = ">= 1.3"
            backend "s3" {
                bucket         = "my-terraform-state-bucket"
                key            = "project/prod/terraform.tfstate"
                region         = "eu-central-1"
                encrypt        = true
                dynamodb_table = "terraform-locks"
            }
        }


        Commands:

            terraform init
            terraform plan -out=tfplan
            terraform apply "tfplan"


#

    LIFECYCLE RULE
    ===============

    A lifecycle rule is a special block within a resource definition that controls how Terraform manages the resource’s creation, update, and deletion.
    It’s mainly used to preserve resources, avoid unintended changes, or force recreation under certain conditions.

    A lifecycle block defines meta-behaviors that affect Terraform’s actions on a resource, it doesn’t change the resource itself, but how Terraform handles 
    it during apply, plan, and destroy.

    Syntax
    -------

    resource "aws_instance" "example" {
        ami           = "ami-123456"
        instance_type = "t3.micro"

        lifecycle {
            create_before_destroy = true
            prevent_destroy       = true
            ignore_changes        = [tags, user_data]
        }
    }


    Lifecycle Arguments
    --------------------
    Argument	            Description	                                                                                            Example Use Case
    ---------               ------------                                                                                            ------------------        
    create_before_destroy	Ensures a new resource is created before the old one is destroyed (useful for zero-downtime updates).	Rolling out a new EC2 instance before terminating the old one.
    prevent_destroy	        Prevents accidental deletion of the resource. Terraform will throw an error if you try to destroy it.	Protecting production S3 buckets or critical IAM roles.
    ignore_changes	        Ignores specific attributes from triggering resource replacement or modification during apply.	        Ignoring drift caused by manual changes, like tags or external scripts.
    replace_triggered_by 	Forces resource replacement when another resource or variable changes.	                                Recreate EC2 instance when an attached security group changes.
    (Terraform 1.2+)


 1.Prevent accidental deletion
 ------------------------------
 Terraform will refuse to destroy this bucket unless you remove or override this rule.

        resource "aws_s3_bucket" "critical_data" {
            bucket = "company-data-bucket"

            lifecycle {
                prevent_destroy = true
            }
        }


 2.Ignore non-critical attribute changes
 ---------------------------------------
 If someone manually updates the tags in AWS, Terraform won’t flag it as drift.

        resource "aws_instance" "web" {
            ami           = "ami-0abc1234"
            instance_type = "t3.micro"

            tags = {
                Name = "WebServer"
            }

            lifecycle {
                ignore_changes = [tags]
            }
        }


 3.Zero downtime replacement
 ----------------------------
 Terraform will first create the new instance, and then destroy the old one — preventing downtime.

        resource "aws_instance" "app" {
            ami           = "ami-0abc1234"
            instance_type = "t3.medium"

            lifecycle {
                create_before_destroy = true
            }
        }


 4.Trigger replacement when dependent changes
 ---------------------------------------------
 If the app_sg security group changes, Terraform will recreate this instance.

        resource "aws_instance" "app" {
            ami           = "ami-0abc1234"
            instance_type = "t3.micro"

            lifecycle {
                replace_triggered_by = [aws_security_group.app_sg]
            }
        }


    Best Practices
    ---------------
    Use prevent_destroy for "production-critical" resources.
    Use "create_before_destroy" to avoid downtime.
    Use "ignore_changes" carefully — it can hide configuration drift.
    Combine with "depends_on" for explicit dependency management.


#

    DATA SOURCES 
    =============
    Data sources allow you to fetch and use existing resources or information from outside your Terraform configuration — instead of creating new ones.


    Syntax Example
    ---------------

    data "aws_vpc" "selected" {
        filter {
            name   = "tag:Name"
            values = ["production-vpc"]
        }
    }

    Then you can reference it like this:

    subnet_ids = data.aws_vpc.selected.id


    Common Use Cases
    Use Case	                                    Example
    Referencing existing AWS resources	            Fetch an existing VPC, subnet, AMI, or security group
    Dynamic lookups	                                Get the latest AMI by name or tag
    Cross-environment references	                Use outputs from another workspace or state
    Cloud metadata	                                Get region, caller identity, or availability zones
    External data	                                Pull data from external files, APIs, or scripts


    Examples by Provider
    ---------------------

    AWS
    ----

    # Get latest Amazon Linux 2 AMI

    data "aws_ami" "amazon_linux" {
        most_recent = true
        owners      = ["amazon"]

        filter {
            name   = "name"
            values = ["amzn2-ami-hvm-*-x86_64-gp2"]
        }
    }

    Azure
    ------
    
    data "azurerm_resource_group" "example" {
        name = "prod-rg"
    }

    Google Cloud
    -------------

    data "google_compute_network" "vpc_network" {
        name = "main-vpc"
    }


    Referencing Data Sources
    -------------------------

    Use the syntax:

    data.<PROVIDER>_<TYPE>.<NAME>.<ATTRIBUTE>


    Example:

    data.aws_vpc.main.id
    data.aws_subnet.selected.cidr_block


    Example: Using Data Sources Together
    -------------------------------------

    data "aws_vpc" "selected" {
        filter {
            name   = "tag:Environment"
            values = ["prod"]
        }
    }

    data "aws_subnets" "selected" {
        filter {
            name   = "vpc-id"
            values = [data.aws_vpc.selected.id]
        }
    }

    resource "aws_instance" "app" {
        ami           = data.aws_ami.amazon_linux.id
        subnet_id     = data.aws_subnets.selected.ids[0]
        instance_type = "t3.micro"
    }


    Notes
    ======
    Data sources are read-only — they do not create or modify resources.
    They are evaluated during plan time, so Terraform must be able to query the source.
    Avoid using them for frequently changing data (e.g., spot prices, timestamps) as that can cause unwanted re-deployments.


    Custom & External Data Sources
    -------------------------------

    You can use the external data source to integrate custom scripts:

    data "external" "example" {
        program = ["python3", "${path.module}/get_data.py"]

        query = {
            key = "value"
        }
    }


#

    META ARGUMENTS
    ===============

    Meta-arguments in Terraform are special configuration arguments that control how Terraform manages or interprets resources and modules — not what they create.
    They allow to influence the lifecycle, dependencies, provider selection, and repetition behavior of Terraform resources.

    Explanation
    ------------
    While normal arguments configure the properties of a resource (e.g., instance_type, bucket, name),
    meta-arguments configure Terraform’s behavior when working with that resource — for example:

    Should Terraform create multiple copies of it? (count, for_each)
    Should Terraform destroy it before or after creating a new one? (lifecycle)
    Which provider should handle this resource? (provider)
    Should it wait for another resource first? (depends_on)

    They are always defined inside a resource or module block.

    Common Terraform Meta-Arguments
    ================================

    depends_on
    ==========

    Defines explicit dependencies between resources.
    Terraform usually detects dependencies automatically (when one resource references another), but use this when the relationship isn’t obvious.

    Example:

    resource "aws_s3_bucket" "logs" {
        bucket = "my-log-bucket"
    }

    resource "aws_instance" "web" {
        ami           = "ami-12345"
        instance_type = "t2.micro"

        depends_on = [aws_s3_bucket.logs]
    }


    Explanation:
    ------------
    Terraform will create the S3 bucket before creating the EC2 instance, even if they don’t reference each other directly.


    count
    ======

    Used to create multiple instances of a resource or module dynamically.

    Example:

    resource "aws_instance" "server" {
        count         = 3
        ami           = "ami-045"
        instance_type = "t2.micro"
    }


    Explanation:
    ------------
    Creates 3 identical EC2 instances, indexed as [0], [1], and [2].

    for_each
    =========

    Creates multiple resources based on a map or set, allowing key-based access and customized attributes.

    Example:

    resource "aws_s3_bucket" "project_buckets" {
        for_each = {
            logs    = "my-log-bucket"
            data    = "my-data-bucket"
    }

    bucket = each.value
        tags = {
            Name = each.key
        }
    }


    Explanation:
    ------------

    Creates two buckets, my-log-bucket and my-data-bucket.
    They can be referenced as aws_s3_bucket.project_buckets["logs"].


    provider
    =========

    Specifies which provider configuration to use when there are multiple providers.

    Example:

    provider "aws" {
        region = "us-east-1"
    }

    provider "aws" {
        alias  = "eu"
        region = "eu-west-1"
    }

    resource "aws_instance" "web_eu" {
        provider = aws.eu
        ami      = "ami-56789"
    }


    Explanation:
    ------------

    Tells Terraform to create the instance using the EU provider configuration, not the default one.


    lifecycle
    ==========

    Controls how Terraform manages the creation, update, and destruction of a resource.

    Example:

    resource "aws_instance" "critical_server" {
        ami           = "ami-12345"
        instance_type = "t2.medium"

        lifecycle {
            prevent_destroy        = true
            create_before_destroy  = true
            ignore_changes         = [tags]
        }
    }


    Explanation:
    -------------
    prevent_destroy         : Avoids accidental deletion
    create_before_destroy   : Ensures zero downtime during replacements
    ignore_changes          : Terraform will ignore tag changes during plan or apply


    Exceptions / Limitations
    -------------------------

    Meta-Argument	        Exceptions / Restrictions
    -------------           --------------------------
    depends_on	            Cannot be used inside module outputs or data blocks.
    count	                Mutually exclusive with for_each — you can’t use both in the same resource.
    for_each	            Only works with maps or sets of strings.
    provider	            Not valid inside data blocks unless explicitly supported.
    lifecycle	            ignore_changes can’t ignore computed-only values (values known only after apply).


    Terraform   count vs for_each — Detailed Comparison
    ====================================================

    Aspect	                        count	                                                            for_each
    =======                         ======                                                              ==========
    Purpose	                        Creates multiple instances of a resource based on a numeric count.	Creates multiple instances of a resource based on elements of a map or set.
    Input type	                    number	                                                            set or map
    How to reference each instance	count.index (0-based integer)	                                    each.key (for maps) and/or each.value (for maps or sets)
    When to use	                    When you have a simple list or just need N copies.	                When each instance must have a unique name or key, or when you have structured data (map, set).
    Creates resources	            resource.name[0], resource.name[1], …	                            resource.name["key1"], resource.name["key2"], …
    Changes in order	            Sensitive — reorders or destroys resources if list order changes.	Stable — keys prevent unwanted recreation.
    Best for	                    Indexed resources (e.g. multiple disks, instances).	                Named resources (e.g. per environment, user, or tag).


            Examples
            ---------

        Example 1: Using count with a list

            variable "users" {
                type    = list(string)
                default = ["alice", "bob", "charlie"]
            }

            resource "local_file" "user_file" {
                count    = length(var.users)
                filename = "${path.module}/${var.users[count.index]}.txt"
                content  = "Hello ${var.users[count.index]}"
            }


            Visualization:
            --------------

            Terraform Plan expands as:

            local_file.user_file[0]
            ├─ filename = ./alice.txt
            └─ content  = Hello alice

            local_file.user_file[1]
            ├─ filename = ./bob.txt
            └─ content  = Hello bob

            local_file.user_file[2]
            ├─ filename = ./charlie.txt
            └─ content  = Hello charlie


            Internals:

            Terraform creates a list-like structure.
            Index count.index runs from 0 to N-1.
            If you reorder the list (e.g., move “bob” before “alice”), indices change → Terraform will destroy and recreate resources.

            Access syntax:

                var.users[count.index] → gives "alice", "bob", "charlie"

                Resource names →

                    local_file.user_file[0]
                    local_file.user_file[1]
                    local_file.user_file[2]


        Example 2: Using for_each with a set

            variable "users" {
                type    = set(string)
                default = ["alice", "bob", "charlie"]
            }

            resource "local_file" "user_file" {
                for_each = var.users
                filename = "${path.module}/${each.value}.txt"
                content  = "Hello ${each.value}"
            }

            Visualization:
            --------------

            Terraform Plan expands as:

            local_file.user_file["alice"]
            ├─ filename = ./alice.txt
            └─ content  = Hello alice

            local_file.user_file["bob"]
            ├─ filename = ./bob.txt
            └─ content  = Hello bob

            local_file.user_file["charlie"]
            ├─ filename = ./charlie.txt
            └─ content  = Hello charlie


            Internals:

            Terraform creates a map-like structure.
            Each item is identified by a unique key ("alice", "bob", "charlie").
            Reordering or adding new users does not destroy existing resources — stable mapping.

            Access syntax:

                each.value → "alice", "bob", "charlie"

                Resource names →

                    local_file.user_file["alice"]
                    local_file.user_file["bob"]
                    local_file.user_file["charlie"]


        Example 3: Using for_each with a map

            variable "user_roles" {
                type = map(string)
                default = {
                    alice   = "admin"
                    bob     = "developer"
                    charlie = "tester"
                }
            }

            resource "local_file" "user_role" {
                for_each = var.user_roles
                filename = "${path.module}/${each.key}.txt"
                content  = "User ${each.key} has role ${each.value}"
            }

            Visualization:
            --------------

            Terraform Plan expands as:

            local_file.user_role["alice"]
            ├─ filename = ./alice.txt
            └─ content  = User alice has role admin

            local_file.user_role["bob"]
            ├─ filename = ./bob.txt
            └─ content  = User bob has role developer

            local_file.user_role["charlie"]
            ├─ filename = ./charlie.txt
            └─ content  = User charlie has role tester


            Internals:

            The map keys (each.key) serve as stable identifiers.
            Removing "bob" only destroys that single resource.
            Adding "dave" adds one new resource — no impact on others.

            Access syntax:

                each.key → "alice", "bob", "charlie"
                each.value → "admin", "developer", "tester"

                Resource names →

                    local_file.user_role["alice"]
                    local_file.user_role["bob"]
                    local_file.user_role["charlie"]


            Notes & Exceptions
            ===================
            Point	                Explanation
            ------                  ------------
            count reorders easily	If you reorder a list, Terraform may destroy and recreate all resources because indices change.
            for_each is stable	    Resources are identified by unique keys — no re-creation unless a key is added/removed.
            You can’t use both	    count and for_each can’t be used in the same resource.
            Type sensitivity	    for_each requires a map or set — lists must be converted (toset(var.list)).
            Plan readability	    for_each gives readable resource names (keys), which is often preferred in production.


    Important Notes
    ================

    Meta-arguments don’t affect the resource itself, only Terraform’s behavior.
    They are available in resource, module, and data blocks (some exceptions).
    Use for_each for named resources; use count when you just need multiple identical copies.
    Always use depends_on sparingly — rely on implicit dependencies whenever possible.
    Be cautious with prevent_destroy in production — it can block necessary replacements.
    Meta-arguments can make your configuration more powerful, but also more complex — use them purposefully.